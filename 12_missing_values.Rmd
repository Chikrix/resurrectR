---
title: "Missing Values"
author: "Chidi"
date: "1/15/2018"
output: html_document
---

```{r setup, include=FALSE, warning=FALSE, echo=FALSE, message=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = TRUE)
```


### Introduction  

```{r warning = FALSE, echo = TRUE, message = FALSE}
library(tidyverse)
library(nycflights13)
library(naniar)
```

R uses **NA**(Not Available) to represent unknown but potentially measurable values. Almost any operation involving NA's would return NA. 

```{r}
NA > 5
10 == NA
NA + 10
NA / 2
NA == NA
```

To understand why this is so;  

```{r}
marys_age <- NA # basically saying we don't know
janes_age <- NA # same as above
marys_age == janes_age # obviously we don't know
marys_age == marys_age # same thing, we don't don't know (R doesn't use reference based assignment :) )
c = 4
d = c
c = 7
d
c
```

To check for NA values, 

```{r}
is.na(marys_age)

is.na(c(32, NA)) ## checks for each item in the vector if it is NA

```

Filtering operation from *dplyr* package returns only items in what is being filtered that evaluates to true and excludes values that are false or NA  

```{r}
mylist = tibble(x = c(2,56,1,5,9,0))
filter(mylist, x %% 2 == 0)
```

### 5.2.4 Exercises 

I solved the the exercises for this section in  [04_manipulation_basics.Rmd](04_manipualtion_basics.Rmd#exercises). 

Some functions that operate on vectors would return NA if the vector has at least one NA value, for example;  
```{r}
flights %>% 
  group_by(year, month, day) %>% 
  summarise(mean = mean(dep_delay))
```

From the above example, the *mean* variable returns NA for each value. This is because aggregation functions like `mean()` would return missing value if there's a missing value in the input, for this reason, almost all aggregation functions has the argument `na.rm` which can be true (remove NA's before aggregating), or false.  
```{r}
flights %>%
  group_by(year, month, day) %>%
  summarise(mean = mean(dep_delay, na.rm = TRUE))
```

In case we encounter unusual values in our dataset, and want to remove those and move on with our analysis without those values, we can either remove rows with those values. This approach isn't recommended because one measurement being wrong doesn't mean the whole observation is wrong, also, incase we have low quality data, by the time I apply this approach to all variables in the data set, I might end up with an insignificant number of rows (if anything)  

A recommended approach is to replace these unusual variables with NA. The easiest way to do this is by using the `mutate` and `ifelse` together, like for example;   

```{r}
diamonds %>%  ## First approach (not recommended)
  filter(between(y, 3, 20))

(diamonds2 <- diamonds %>%  ## recommended approach
  mutate(y = ifelse(y < 3 | y > 20, NA, y)))
```

Also, when plotting data that has missing values, ggplot2 excludes those values but also warns us of the number of the values that were removed from the plot because they're missing values.  

```{r warning = TRUE}
ggplot(diamonds2, aes(x, y)) +
  geom_point()
```

To suppress the warning message printed by the plot, we can use the `na.rm = TRUE` argument in the geom function, like;  

```{r}
ggplot(diamonds2, aes(x, y)) +
  geom_point(na.rm = TRUE)
```

Sometimes, we want to know what makes observations with missing values different from those with observed values. For example, in the flights data set (nycflights13 dataset), *dep_time* being NA means the flight was cancelled, so we might want to compare the scheduled departure time for cancelled and non cancelled flights. To do this, first we create a variable for the cancelled or not cancelled flights   

```{r}
flights %>%
  mutate(
    cancelled = is.na(dep_time),
    sched_hr = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hr + sched_min / 60
  ) %>%
  ggplot(aes(sched_dep_time)) +
    geom_freqpoly(aes(colour = cancelled), binwidth = 1/4)
```

From the above plot, I see that there're more non cancelled flights than cancelled ones.  

### Exercises  

1. What happens to missing values in a histogram? What happens to missing values in a bar chart? Why is there a difference?  

```{r}
ggplot(diamonds2, aes(y)) +
  geom_histogram(binwidth = 0.05)

diamonds2 %>%
  mutate(cut = ifelse(is.na(y), NA, cut)) %>%
  ggplot(aes(cut), aes(cut)) +
    geom_bar()
```

For a histogram or bar chart, ggplot removes bars for the NA points, and shows a warning message that it removed the rows with missing values (non-finite values). I saw no difference (so maybe my answer is wrong).  
##### 2. What does na.rm = TRUE do in mean() and sum()? 

It filters out NA values from the provided vector, before performing mean or sum operation.  
