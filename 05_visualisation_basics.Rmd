---
title: "Visualisation Basics II"
author: "Chidi"
date: "12/14/2017"
output: html_document
---

```{r setup, include=FALSE, warning=FALSE, echo=TRUE, message=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  comment = "#>",
  collapse = TRUE,
  cache = TRUE)
```

### Introduction  

**Statistical transformations** (stats) allows us plot summaries of the data, and are useful for visualisations like the histogram.  **Position adjustments** helps handle overlapping objects. **Coordinate systems** control how x and y map to position on the plot.

### Statistical Transformations  

```{r include = FALSE, warning = FALSE}
library(tidyverse)
library(nycflights13)
```


```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

To make a plot, charts like histogram, bar charts, frequency polygons, etc bin your data and then plot bin counts. Smooters fit a model on the data and then plot predictions from the model. Boxplots compute a robust summary of the distribution which it displays in a specially formatted box.  For each geom we use, we can check the `stat` it uses using the `stat` argument of the geom (check the geom's doc - `?geom_bar`), and we can set for the one we want. The *Computed variables* section for these stat functions tells how it computes the stats it uses, and provides good pointers on the stats used by the geom function. We can create the geom functions of statistical transformation graphs using their direct stat functions, for example, I can recreate the bar chat above using the `stat_count`, note that the one I made above used the `count` stat, I could still use the `prop` stat, which would compute groupwise proportions  

```{r}
ggplot(diamonds) +
  stat_count(mapping = aes(x = cut))
```

This works because every geom has a default stat, and every stat has a default geom. This means we can plot graphs with statistical transformations without having to worry about the stats used, however, there're reasons why it may be important to specify the kind of stat we want;

* We might want to override the default stat or geom. for example, say I want to create a bar chart, where I have a category and the size of the category (note, not the computed frequency)  

```{r}
demo <- tribble(
  ~cut,        ~freq,
  "Fair",      1610,
  "Good",      4960,
  "Very Good", 12082,
  "Premium",   13791,
  "Ideal",      21551
)

ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")
```

The above plot shows a bar chart, however, note that the `cut` axis is the one we provide, this is the most common way bar charts are thought of, unlike the earlier example where the count was computed and we didn't have to provide `freq`  

* You might want to override the default mapping from transformed variables to aestistics. For example, I might want a bar chart to show proportions instead of count. Example;  

```{r}
ggplot(diamonds) +
  geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))
```

* I might want to draw more attention to the statistical transformation. For example, I might want to use `stat_summary()`, which would summarise the y values for each unique x value.  

```{r}
ggplot(diamonds) +
  stat_summary(mapping = aes(x = cut, y = depth),
               fun.ymin = min,
               fun.ymax = max,
               fun.y = median, geom = "pointrange")

diamonds %>%
  group_by(cut) %>%
  summarise(minimum = min(depth, na.rm = TRUE),
            maxinum = max(depth, na.rm = TRUE),
            average = median(depth, na.rm = TRUE))
```

What the plot does is plot the summary I made below for each cut group. That is awesome. ggplot2 provides over 20 `stat` functions we can use. Use the data visualisation cheatsheet to also learn more, also check the doc for each to learn more, eg `?stat_bin`  

### Exercises  

##### 1. What is the default geom associated with stat_summary()? How could you rewrite the previous plot to use that geom function instead of the stat function?  

The default geom associated with `stat_summary()` is `pointrange`. To rewrite the plot above.  

```{r}
ggplot(diamonds, mapping = aes(cut, depth)) +
  geom_pointrange(stat = "summary",
                  fun.ymin = min, 
                  fun.ymax = max,
                  fun.y = mean)
```

##### 2. What does geom_col() do? How is it different to geom_bar()?  

```{r}
diamonds %>%
  group_by(cut) %>%
  summarise(
    count = n(),
    minimum = min(depth, na.rm = TRUE),
    maxinum = max(depth, na.rm = TRUE),
    average = median(depth, na.rm = TRUE)) %>%
  print(.) %>% 
  ggplot(., aes(x = cut, y = average)) +
  geom_col()
```

The `geom_col` creates a bar chart with the x and y variables we provide. Unlike `geom_bar` whose y axis is a statistical transformation of the number of cases of x, in `geom_col` the height of the bars is the actual values in the dataset. 

##### 3. Most geoms and stats come in pairs that are almost always used in concert. Read through the documentation and make a list of all the pairs. What do they have in common?  

See [ggplot2 documentation](http://ggplot2.tidyverse.org/reference/) 

##### 4. What variables does stat_smooth() compute? What parameters control its behaviour?

```{r}
ggplot(diamonds, mapping = aes(carat, price)) +
  geom_point() +
  stat_smooth()
```

Variables important for `stat_smooth` are the same `geom_smooth`, these includes, x, y, ymin, ymax, se. parameters that control its behavior are `method`.  

##### 5. In our proportion bar chart, we need to set group = 1. Why? In other words what is the problem with these two graphs?  

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..prop..))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = color, y = ..prop..))
```

I think the group helps us know how the x values are grouped relative to the y value, kind of helps us add some dimension to the plot. So by setting the group to be 1, we say we want one bar per category, by setting the group to a categorical variable, we're saying we want that number of group categories on the x axis for each of the category. The intended plot may be; 

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = color, y = ..prop.., group = color), position = "dodge")
```